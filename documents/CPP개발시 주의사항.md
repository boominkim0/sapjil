# C++로 게임 엔진 만들 때 주의 깊게 생각해야 할 것들

> 목표: “일단 돌아가는 엔진”이 아니라, **확장 가능**하고 **디버깅 가능**하며 **성능/안정성**이 무너지지 않는 엔진을 만들기 위한 체크리스트입니다.
> 
> 이 문서는 “처음부터 Unreal급”이 아니라도, **나중에 반드시 발목 잡히는 지점**들을 미리 피하는 데 초점을 둡니다.

---

## 1) 엔진의 범위(스코프)부터 고정하기

엔진은 기능이 아니라 **제품**입니다. 범위가 흔들리면 구조가 흔들립니다.

### 최소 스코프(추천: 1~3개월)
- 플랫폼 1개(PC만, 또는 Web만)
- 렌더 파이프라인 1개(2D만 또는 3D만)
- 씬 전환 1~2개(Title/Game)
- 리소스: Texture + Font + Sound 정도
- 물리: 없다(또는 단순 AABB)

### 결정을 문서로 남겨야 하는 것
- 좌표계(오른손/왼손, Y-up/Z-up, 픽셀 좌표 기준)
- 시간 단위(초 기반 float? fixed timestep?)
- 스레딩 정책(단일 스레드로 시작할지)
- 에셋 파이프라인(원본 vs 변환본)

---

## 2) 게임 루프/시간(Time) 설계가 엔진 품질을 좌우함

### 반드시 정해야 하는 계약(Contract)
- 입력 샘플링 시점: update 시작? 끝?
- update에서의 dt 단위: **seconds**를 강력 추천
- 고정 업데이트(fixed)와 가변 업데이트(variable) 분리 여부

### 흔한 함정
- dt를 프레임마다 그대로 쓰면:
  - 프레임드랍 시 물리/이동이 튀고
  - 네트워크/리플레이/테스트가 어려워짐

### 권장 패턴(대표)
- **Fixed timestep** (물리/게임플레이) + **Variable render** (그리기)
- 누적기(accumulator) 방식

---

## 3) 메모리/리소스 수명(Ownership) 규칙을 “팀 규칙”으로 만들기

C++ 엔진에서 제일 많이 터지는 문제는 “누가 소유하고 언제 해제하냐”입니다.

### 최소 규칙 세트
- **Load/Unload는 반드시 페어**로 관리
- 리소스는 `AssetManager`가 소유 (게임 오브젝트가 직접 `Unload` 금지)
- GPU 리소스는 **렌더 스레드/컨텍스트 생명주기**와 묶일 수 있음

### 스마트 포인터를 무조건 쓰면 해결될까?
- `shared_ptr`는 편하지만:
  - 순환 참조(cycle) 위험
  - 해제 시점 불명확(프레임 중간 free)
  - 성능(원자 ref count)

**추천:**
- “장기 리소스(Texture, Mesh)”는 핸들(Handle) + 매니저
- “게임 객체 소유”는 `unique_ptr` 중심

### 꼭 체크할 항목
- 프레임 중간에 리소스가 해제되면 GPU에서 크래시 가능
- “씬 전환 시 일괄 정리”가 가능한 구조인지

---

## 4) 데이터 지향(ECS) vs OOP: 정답은 없고, 비용이 다름

### 선택 기준
- 오브젝트 수가 적고 단순: OOP도 충분
- 수천~수만 개 엔티티/컴포넌트: ECS가 이점

### ECS를 도입할 때 흔한 함정
- 처음부터 범용 ECS를 만들다 엔진이 끝남
- 디버깅/툴링이 없으면 “데이터는 빠른데 개발이 느려짐”

**추천 시작점:**
- “소형 ECS” 또는 “Component + System 목록” 정도로 시작
- 성능보다 먼저 **편의성/디버깅** 확보

---

## 5) 렌더링: API보다 “리소스 바인딩 규칙”이 중요

### 렌더 시스템에서 미리 정해야 하는 것
- 렌더 스테이트 변경 최소화 전략(배칭, 정렬)
- 카메라/좌표 변환 기준
- 투명(알파) 오브젝트 정렬 규칙
- 텍스처 아틀라스/스프라이트 배칭 여부

### 흔한 함정
- 모든 오브젝트가 `Draw()`에서 바로 GPU 호출 → 드로우콜 폭발
- “렌더링 코드 = 게임 로직”이 섞이면 유지보수 지옥

**추천 구조:**
- 게임 로직은 `RenderCommand`(또는 `DrawList`)에만 기록
- 렌더러는 한 곳에서만 GPU 호출

---

## 6) 입력(Input): ‘현재 상태’와 ‘엣지(Pressed/Released)’를 분리

### 최소 기능
- 키/마우스/패드의
  - `Down`(누르고 있음)
  - `Pressed`(이번 프레임에 눌림)
  - `Released`(이번 프레임에 떼짐)

### 흔한 함정
- OS 이벤트를 바로 게임 로직으로 흘려보냄 → 프레임 단위 재현 불가

**추천:**
- 이벤트 수집 → 프레임 시작에 상태 스냅샷 만들기

---

## 7) 씬/게임 상태 전환(Scene/State) 설계

### 최소 요구사항
- `Title → Game → Pause → GameOver` 같은 흐름이
  - 깔끔히 전환되고
  - 리소스 정리/로드가 확실하고
  - 이전 씬이 참조로 살아남지 않게

### 체크해야 할 포인트
- 씬 전환 중 “중간 프레임”이 존재하는가?
- 로딩(비동기) 화면을 넣을 수 있는가?
- 전환 애니메이션(페이드) 구현이 쉬운 구조인가?

---

## 8) 직렬화/세이브/리플레이(나중에 반드시 필요해짐)

엔진이 커질수록 “재현 가능성”이 중요해집니다.

### 우선순위 높은 순
1) 설정 파일(그래픽/사운드) 저장
2) 씬 생성 데이터(레벨 로딩)
3) 리플레이/디버그 재현(입력 기록)

### 흔한 함정
- 포인터 주소 기반 직렬화
- 버전 관리 없는 저장 포맷

**추천:**
- ID 기반 참조
- 버전 필드 포함
- JSON은 디버그용, 실제는 바이너리/패킹 고려 가능

---

## 9) 멀티스레딩: 성능보다 먼저 “결정론/디버그”가 무너짐

### 현실적인 접근
- 처음엔 단일 스레드로 안정성을 확보
- 필요해지면 단계적으로:
  - 로딩 스레드(파일 IO)
  - 오디오
  - 렌더 준비(커맨드 빌드) 정도부터

### 체크 포인트
- 작업 큐(job system) 도입 시, 디버그 모드에서 단일 스레드로도 동작 가능한가?
- 데이터 레이스가 나면 재현이 매우 어려움

---

## 10) 툴/디버깅 기능은 “나중에”가 아니라 “처음부터”

### 꼭 넣으면 좋은 것들
- 로그(레벨/카테고리/파일+라인)
- assert(개발 빌드에서 적극 사용)
- 디버그 오버레이(FPS, drawcall, 메모리, 엔티티 수)
- 간단한 개발용 콘솔 명령(teleport, spawn 등)

### 흔한 함정
- 로그가 너무 많아 성능 저하 → 레벨/필터 필수

---

## 11) 에셋 파이프라인(콘텐츠) 없으면 엔진이 아니라 데모가 됨

### 최소 파이프라인
- 원본(PSD/PNG/FBX/WAV) → 변환본(엔진용) 분리
- 해시/타임스탬프 기반 재빌드
- 핫리로드(가능하면)

### 체크 포인트
- 경로 규칙(상대/절대)
- 플랫폼별 압축/포맷 차이

---

## 12) 빌드/배포: “내 PC에서만 됨”을 막는 구조

### 추천 습관
- CMake(또는 단일 빌드 시스템)로 통일
- 외부 라이브러리는
  - 서브모듈/FetchContent/vcpkg 등으로 재현 가능하게
- CI에서 최소 빌드 확인

### 모듈 경계
- `engine/`는 게임 프로젝트 없이도 빌드 가능해야 함
- `game/`은 엔진 API만 사용

---

## 13) API 설계: ‘사용하기 쉬움’이 성능보다 먼저다

### 좋은 엔진 API의 특징
- 한 번 사용하면 “틀리게 쓰기 어려움”(misuse-resistant)
- 객체의 유효성/수명 규칙이 코드로 드러남
- 실패가 조용하지 않음(명확한 에러/로그)

### 흔한 함정
- 모든 게 전역 싱글톤
- 모든 함수가 어디서든 호출 가능(상태 꼬임)

---

## 14) 성능 최적화는 측정 이후에, 하지만 “측정 장치”는 먼저

### 최소 장비
- 프레임 타임(ms) 측정
- 구간 타이머(스코프 프로파일러)
- 메모리 사용량/할당 횟수

### 흔한 함정
- 최적화보다 먼저 구조를 망가뜨림

---

## 15) 보안/안정성: 크래시를 “빨리” 발견하는 구조

### 체크 포인트
- release에서 assert가 사라지면 어떤 안전장치가 남는가?
- NaN/INF가 들어오면 어떻게 되는가?

**추천:**
- 개발 빌드에서 강한 검증
- 릴리즈에서는 실패를 “안전한 방식”으로 처리(로그 + fallback)

---

## 16) 현실적인 추천 로드맵(작게 시작하기)

### 0단계: 데모
- 창/루프/입력/간단 렌더

### 1단계: 엔진 뼈대
- `Engine::Init/Update/Shutdown`
- `Scene` 전환
- `AssetManager`(Load/Unload)

### 2단계: 게임이 되는 수준
- 스프라이트 배칭
- 카메라
- 기본 UI(텍스트)
- 간단 충돌

### 3단계: 개발이 편해지는 수준
- 디버그 오버레이
- 핫리로드(선택)
- 에디터/레벨 로딩(선택)

---

## 빠른 체크리스트(요약)

- [ ] 시간/루프 계약(dt, fixed/variable)
- [ ] 소유권 규칙(누가 언제 free?)
- [ ] 씬 전환과 리소스 정리 전략
- [ ] 렌더링과 게임 로직 분리(RenderCommand)
- [ ] 입력의 상태/엣지 분리
- [ ] 디버그 도구(로그/오버레이/assert)
- [ ] 에셋 파이프라인(원본/변환본)
- [ ] 빌드 재현성(CMake/의존성/CI)

---

## 덧붙임: 이 프로젝트(raylib 학습) 맥락에서의 제안

현재처럼 raylib로 학습 중이라면, 엔진을 만들기 전에 아래 3가지만 먼저 적용해도 체감이 큽니다.

1) dt(seconds) 기반 이동으로 통일
2) `SceneId` + `switch`로 상태 전환 만들기(Title/Game)
3) 텍스처/사운드 로드는 `Load/Unload` 위치를 한 군데로 모으기(씬 또는 매니저)

원하면 지금 `main.cpp`를 **Scene 구조 + dt + 간단 tween(페이드/스케일)** 이 들어간 형태로 리팩터링해줄게요.
